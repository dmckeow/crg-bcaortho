---
title: "Orthology Results: Assessing the initial orthogroups (homogroups) 155 metazoans"
author: "Dean Mckeown"
date: "`r Sys.Date()`"
output: 
  html_document:
    output_file: "../results/homogroups.html"
    toc: true
    toc_float: TRUE
    toc_depth: 4
    number_sections: true
    theme: united
    highlight: tango
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.path = "../results/")
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{css, echo=FALSE}
.scroll-200 {
  max-height: 200px;
  overflow-y: auto;
  background-color: inherit;
}
```

___

## Preparation
We will begin by creating a variable that specifies where all workflow outputs are stored. Additionally we will source the script containing helper functions, and setting to variable some colors that we'll use throughout. 
### Inputs needed

/users/asebe/dmckeown/projects/crg-bcaortho/project-ioo_mz155/results/orthofinder_results/orthofinder_mcl/Orthogroups.tsv
  * **Pipeline generated, for any orthocaller** - which homogroups contain what sequences

/users/asebe/dmckeown/projects/crg-bcaortho/project-ioo_mz155/results/prefilter/initial/defline_info/*.csv
  * **Pipeline generated, for any orthocaller** - hmmsearch assignment for each sequence

/users/asebe/dmckeown/projects/crg-bcaortho/project-ioo_mz155/results/orthofinder_results/orthofinder_mcl/Orthogroups.GeneCount.tsv
  * **Pipeline generated, for any orthocaller** - just Orthogroups.tsv just totals instead of deflines

/users/asebe/xgraubove/genomes/annotation_functional/*_long.pep.pfamscan.csv
  * **Precalculated functional annotations**, needs gene id, PFAM accession for OG homogeneity assessment by cogeqc

### Inputs that MIGHT be needed, but currently only available for orthofinder
/users/asebe/dmckeown/projects/crg-bcaortho/project-ioo_mz155/results/orthofinder_mcl/complete_dataset/Results_Inflation_2.5/Comparative_Genomics_Statistics/Statistics_PerSpecies.tsv
  * Basic stats of ortholog size etc by species

/users/asebe/dmckeown/projects/crg-bcaortho/project-ioo_mz155/results/orthofinder_mcl/complete_dataset/Results_Inflation_2.5/Comparative_Genomics_Statistics/Orthogroups_SpeciesOverlaps.tsv
  * matrix of all samples vs all - might need to hunt down OF code
  * the number of orthogroups shared between each species-pair as a square matrix.

```{r Preparation, results = FALSE}
suppressPackageStartupMessages(suppressWarnings(source('R/packages.R')))
suppressPackageStartupMessages(suppressWarnings(source('R/homogroup-functions.R')))

################################################################################
# INPUTS
################################################################################

################################################################################
# Pipeline run inputs
################################################################################
RESULT_DIR  <-  "/no_backup/asebe/dmckeown/test_br_array_vs_br/results/"
SAMPLESHEET <- "../inputs/samplesheet1-10.csv"
PIPELINE_RUN_NAME <- "test_br_array_vs_br" # we will use this later to identify runs if comparing them this way

#SPECIES_TREE <- paste0(RESULT_DIR, 'speciesrax/species_trees/inferred_species_tree.newick') # internal speciesrax tree will be here
SPECIES_TREE <- '../../../../gzolotarov/projects/2021_TFevol/metazoan_tf_evol_2022/030523_phylogenies/data_annotation/species_tree.newick'

################################################################################
# Orthogroup caller specific stuff (subworkflow i.e. orthofinder, broccoli)
################################################################################

OGS_TSV_PATH_OF <- paste0(RESULT_DIR, "orthofinder_results/orthofinder_mcl/Orthogroups.tsv")
OGS_TSV_PATH_BR <- paste0(RESULT_DIR, "broccoli_array_results/broccoli/Orthogroups.tsv")

################################################################################
# General inputs
################################################################################
# Colour palette (must match taxonomy in samplesheet1)

SUPERGROUP_COLS <- c(
  Choanoflagellata = "#BEBADA",
  Cnidaria = "#FB8072",
  Ctenophora = "#80B1D3",
  Deuterostomia = "#8DD3C7",
  Filasterea = "#FDB462",
  #Placozoa = "#B3DE69",
  Porifera = "#FCCDE5",
  Protostomia = "#FFFFB3"
  #Teretosporea = "#D9D9D9"
)

LONG_PEP_PFAMSCAN_CSVS <- list.files("../../../../xgraubove/genomes/annotation_functional/", pattern = "*_long.pep.pfamscan.csv", full.names = TRUE)

GENE_FAMILIES_SEARCH_INFO <- "../../../../climate-adaptation-corals-ops/results_annotation/data/gene_families_searchinfo.csv"

################################################################################
# OUTPUTS
################################################################################
# And where summarized results should be saved.
OUTPUT_DIR <- './results/'
dir.create(OUTPUT_DIR, showWarnings = F)
dir.create(paste0(OUTPUT_DIR, 'orthofinder'), showWarnings = F)


################################################################################
# LOAD DATA
################################################################################
########################################
# data from pipeline run samplesheet
samplesheet <- read.delim(SAMPLESHEET, sep = ",")
species_list <- unique(samplesheet$id)
########################################
# Get all defline info 
file_paths <- list.files(paste0(RESULT_DIR, "prefilter/initial/defline_info/"), 
                          pattern = "*.csv", full.names = TRUE)
defline_info <- lapply(file_paths, read.csv)
defline_info <- do.call(rbind, defline_info)

# Collapse defline info to one line per defline, collapsed gene family hit from pipeline info

defline_info <- defline_info %>%
  group_by(seq) %>%
  summarise(
    gene_family_names = paste(unique(gene_family_name), collapse = ", "),
    preprocessed_fasta_paths = paste(unique(preprocessed_fasta_path), collapse = ", "),
    # Keep the first value of other columns (they are the same for each group)
    parent_seq = first(parent_seq), 
    clean_seq = first(clean_seq),
    clean_parent_seq = first(clean_parent_seq),
    id = first(id),
    input_fasta_path = first(input_fasta_path),
    .groups = "drop"
  )

########################################
# Prepare functional annotations for your genes
# Filter down to only csvs for ids in the pipeline run (filename dependent)
LONG_PEP_PFAMSCAN_CSVS <- LONG_PEP_PFAMSCAN_CSVS[sapply(LONG_PEP_PFAMSCAN_CSVS, function(x) {
  any(sapply(species_list, function(species) grepl(species, x)))
})]

# This is the specific header for these annotations
pfam_header <- c("pfam_seq_id", "pfam_alignment_start", "pfam_alignment_end", "pfam_envelope_start", "pfam_envelope_end", 
                  "pfam_hmm_acc", "pfam_hmm_name", "pfam_type", "pfam_hmm_start", "pfam_hmm_end", "pfam_hmm_length", 
                  "pfam_bit_score", "pfam_E_value", "pfam_significance", "pfam_clan")

# Read the filtered CSV files
functional_annotations <- lapply(LONG_PEP_PFAMSCAN_CSVS, clean_pfam_scan_file, header = pfam_header)
# Filter down to only genes within the OG dataset

functional_annotations <- lapply(functional_annotations, function(annotation_df) {
  annotation_df %>%
    filter(pfam_seq_id %in% defline_info$parent_seq)  # Filter where seq_id is in parent_seq
})

# Final merge of the annotations
functional_annotations <- do.call(rbind, functional_annotations)

# Add useful info from deflines info, duplicates info if using domains from proteins
functional_annotations <- functional_annotations %>%
    left_join(defline_info, by = c("pfam_seq_id" = "parent_seq"))

# Prepare helpful annotations for assessing orthogroups and deflines
functional_annotations_for_ogs <- functional_annotations %>%
                                      filter(!is.na(pfam_hmm_acc)) %>%
                                      filter(pfam_type == "Domain") %>%
                                      select(
                                        pfam_seq_id,
                                        pfam_hmm_acc,
                                        pfam_hmm_name,
                                        pfam_type,
                                        pfam_clan
                                      ) %>%
                                      unique()
functional_annotations_for_deflines <- functional_annotations_for_ogs %>%
                                   unique() %>%
                                      group_by(pfam_seq_id) %>%
                                      summarise(
                                        pfam_hmm_accs = paste(pfam_hmm_acc, collapse = ","),
                                        pfam_hmm_names = paste(pfam_hmm_name, collapse = ","),
                                        pfam_types = paste(pfam_type, collapse = ","),
                                        pfam_clans = paste(pfam_clan, collapse = ",")
                                      ) %>%
                                      unique()

########################################
# Prep COGEQC inputs
# Reduce to annotations for COGEQC

functional_annotations_cogeqc <- functional_annotations %>%
    filter(!is.na(pfam_hmm_acc)) %>% 
    filter(pfam_type == "Domain") %>% 
    select(
      id,
      clean_seq,
      pfam_hmm_acc
    ) %>%
    rename(
      Species = id,
      Gene = clean_seq,
      Annotation = pfam_hmm_acc
    ) %>%
    unique()
  
# split into lists by species
functional_annotations_cogeqc <- functional_annotations_cogeqc %>% 
  split(functional_annotations_cogeqc$Species) %>%
  lapply(function(df) {
    df %>%
      select(-Species)
  })


########################################
# Load Orthogroup info for each OG caller
orthogroups <- list()
orthogroups$orthofinder <- cogeqc::read_orthogroups(OGS_TSV_PATH_OF) %>% 
                                  filter(!is.na(Orthogroup)) %>% 
                                  mutate(OG_source = "orthofinder") %>% 
                                  unique()
orthogroups$broccoli <- cogeqc::read_orthogroups(OGS_TSV_PATH_BR) %>% 
                                  filter(!is.na(Orthogroup)) %>%
                                  mutate(OG_source = "broccoli") %>% 
                                  unique()
orthogroups <- do.call(rbind, orthogroups)

# reshape for COGEQC
orthogroups_cogeqc <- list()
orthogroups_cogeqc$orthofinder <- cogeqc::read_orthogroups(OGS_TSV_PATH_OF) %>% 
                                  filter(!is.na(Orthogroup)) %>% 
                                  unique()
orthogroups_cogeqc$broccoli <- cogeqc::read_orthogroups(OGS_TSV_PATH_BR) %>% 
                                  filter(!is.na(Orthogroup)) %>%
                                  unique()

# Calculate mean orthogroup homogeneity scores across species
# Some OGs have no scores despite having many seqs e.g. OG_12 broccoli
og_hscores <- list()
og_hscores[["orthofinder"]] <- get_cogeqc_hscores(orthogroups_cogeqc[["orthofinder"]], functional_annotations_cogeqc)
og_hscores[["broccoli"]] <- get_cogeqc_hscores(orthogroups_cogeqc[["broccoli"]], functional_annotations_cogeqc)

# Generate violin plot of homogeneity scores between tools/runs, make scores scaled
cogeqc_outputs <- compare_homogeneity_scores(
  og_hscores[["orthofinder"]],
  og_hscores[["broccoli"]],
  comps = list(c("orthofinder", "broccoli"))
)
# Add COGEQC scores to OG info
orthogroups_for_deflines <- orthogroups %>%
  left_join(cogeqc_outputs[["og_hscores_scaled_all"]], by = c("Orthogroup" = "Orthogroup")) %>%
  select(-Source) %>%
  rename(
      cogeqc_hscore = Score,
      cogeqc_hscore_scaled = Score_scaled
  ) %>%
  unique()

########################################
# Merge useful information with the defline info

merged_data <- defline_info %>%
    left_join(samplesheet, by = c("id" = "id")) %>%
    rename(
      supergroup = taxonomy
    ) %>%
    select(-fasta)

# Merge with orthogroups data
merged_data <- merged_data %>%
    left_join(orthogroups_for_deflines, by = c("clean_seq" = "Gene")) %>%
    select(-Species)

# functional_annotations_for_deflines
main_deflines <- merged_data %>%
    left_join(functional_annotations_for_deflines, by = c("parent_seq" = "pfam_seq_id"))

# make OG centric dataframe
main_ogs <- main_deflines %>%
    select(
      Orthogroup,
      seq,
      parent_seq,
      clean_seq,
      clean_parent_seq,
      id,
      supergroup,
      OG_source,
      cogeqc_hscore,
      cogeqc_hscore_scaled
    ) %>%
    left_join(functional_annotations_for_ogs, by = c("parent_seq" = "pfam_seq_id")) %>%
    bind_rows() %>%
    group_by(Orthogroup) %>%
    summarise(
      seqs = paste(unique(seq), collapse = ","),
      parent_seqs = paste(unique(parent_seq), collapse = ","),
      clean_seqs = paste(unique(clean_seq), collapse = ","),
      clean_parent_seqs = paste(unique(clean_parent_seq), collapse = ","),
      ids = paste(unique(id), collapse = ","),
      supergroups = paste(unique(supergroup), collapse = ","),
      OG_source = unique(OG_source),
      cogeqc_hscore = unique(cogeqc_hscore),
      cogeqc_hscore_scaled = unique(cogeqc_hscore_scaled),
      pfam_hmm_accs = paste(unique(pfam_hmm_acc), collapse = ","),
      pfam_hmm_names = paste(unique(pfam_hmm_name), collapse = ","),
      pfam_types = paste(unique(pfam_type), collapse = ","),
      pfam_clans = paste(unique(pfam_clan), collapse = ","),
      total_seqs = length(unique(seq)),
      total_parent = length(unique(parent_seq)),
      total_ids = length(unique(id)),
      total_supergroups = length(unique(supergroup)),
      most_common_pfam_hmm_name = get_mode(pfam_hmm_name),
      total_most_common_pfam_hmm_name = count_mode(pfam_hmm_name, get_mode(pfam_hmm_name)),
      percent_most_common_pfam_hmm_name = (total_most_common_pfam_hmm_name / length(pfam_hmm_name)) * 100
    )


  
```
___

## Homogroup Homogeneity
```{r Homogroup homogeneity}


cogeqc_outputs[["og_hscores_scaled_violin"]]

ggsave(cogeqc_outputs[["og_hscores_scaled_violin"]], filename = paste0(OUTPUT_DIR, "og_homogeneity_by_source.png"), 
           height = 6, width = 12, dpi = 300)





```

---

## Algorithm Comparison
```{r Algorithm Comparison}
# Create lists of sequences associated with each algorithm
compare_callers <- list()
compare_callers[["orthofinder"]] <- split(all_data[["orthofinder"]][["clean_seq"]], all_data[["orthofinder"]][["Orthogroup"]])
compare_callers[["orthofinder"]] <- lapply(compare_callers[["orthofinder"]], unique)

compare_callers[["broccoli"]] <- split(all_data[["broccoli"]][["clean_seq"]], all_data[["broccoli"]][["Orthogroup"]])
compare_callers[["broccoli"]] <- lapply(compare_callers[["broccoli"]], unique)

# Initialize an empty list to store the Jaccard similarity matrices
jaccard_results <- list()

# Perform a comparison and store the result in the list with a meaningful name
jaccard_results$of_vs_br <- calculate_jaccard_similarity(compare_callers[["orthofinder"]], compare_callers[["broccoli"]])
jaccard_results$of_vs_of <- calculate_jaccard_similarity(compare_callers[["orthofinder"]], compare_callers[["orthofinder"]])
jaccard_results$br_vs_br <- calculate_jaccard_similarity(compare_callers[["broccoli"]], compare_callers[["broccoli"]])

# Assuming jaccard_results is a list with matrices for each pair
metrics_of_vs_br <- calculate_jaccard_metrics(jaccard_results$of_vs_br, "orthofinder", "broccoli")
metrics_br_vs_br <- calculate_jaccard_metrics(jaccard_results$br_vs_br, "broccoli", "broccoli")
metrics_of_vs_of <- calculate_jaccard_metrics(jaccard_results$of_vs_of, "orthofinder", "orthofinder")

metrics_all <- rbind(metrics_of_vs_br, metrics_br_vs_br, metrics_of_vs_of)

metrics_all_long <- metrics_all %>%
  gather(key = "Metric", value = "Value", -tool1, -tool2)

# Create the heatmap using ggplot2
ggplot(metrics_all_long, aes(x = tool1, y = tool2, fill = Value)) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0.5) + 
  facet_wrap(~Metric, scales = "free") +
  theme_minimal() +
  labs(
    title = "Heatmaps of Metrics by Tool Pair",
    x = "Tool 1", y = "Tool 2", fill = "Value"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(strip.text = element_text(size = 12))


```

```{r Taxonomic Distribution}
# Example usage with your data frame (df_main)
upset_input <- list()
upset_input$orthofinder <- create_presence_matrix(all_data[["orthofinder"]], supergroup, Orthogroup)
upset_input$broccoli <- create_presence_matrix(all_data[["broccoli"]], supergroup, Orthogroup)

upset_input_all <- upset_input %>% bind_rows() # flatten the 

# join in metadata to maybe use in plot
 
upset_input_all <- upset_input_all %>% 
    select(Orthogroup, Source) %>%
    left_join(upset_input_all, by = c("Orthogroup" = "Name"))

supergroups <- c("Choanoflagellata", "Cnidaria", "Ctenophora", "Deuterostomia", "Filasterea", "Porifera", "Protostomia")


  

upset(upset_input_all,
  supergroups,
  annotations = list(
      'Orthogroup caller'=(
          ggplot(mapping=aes(fill=Source))
          + geom_bar(stat='count', position='fill')
          + scale_y_continuous(labels=scales::percent_format())
          + scale_fill_manual(values=c(
              'orthofinder'='#E41A1C', 'broccoli'='#377EB8'
          ))
          + ylab('Orthogroup caller')
      )
  ),
)


```